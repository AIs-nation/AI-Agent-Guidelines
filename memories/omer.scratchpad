~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ AUTOMATION DEVELOPMENT ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
Lesson Learned: When creating automation scripts, keep them simple and focused on the core functionality. A simple script that focuses cursor, clicks input, selects all text, types prompt, and waits is much more reliable than complex scripts with sophisticated detection.
Good Example: ✅ Simple functions for each step (focus_cursor, click_input_box, select_all_text, type_prompt, wait_5_minutes) with clear error handling and progress reporting
Bad Example: ❌ Complex scripts with sophisticated input detection, multiple fallback methods, and async operations that can introduce more failure points

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ UI ELEMENT DETECTION ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
Lesson Learned: When clicking input boxes in automation, use relative positioning based on screen resolution rather than fixed coordinates. Also ensure proper focus by clicking multiple times and adding extra focus steps.
Good Example: ✅ Calculate click position as percentage of screen size (50% width, 90% height for bottom input), click twice to ensure focus, add extra focus verification step
Bad Example: ❌ Using fixed coordinates like (800, 800) that may not work on different screen sizes or window layouts

Lesson Learned: For highest confidence input box detection, use window-relative positioning first, then fallback to multiple screen positions with functional testing to verify success.
Good Example: ✅ Method 1: Find Cursor window ID, get geometry, calculate input position relative to window. Method 2: Try multiple likely positions and test each by typing/deleting a space to verify focus works
Bad Example: ❌ Only using single fixed position without testing if the click actually worked or found the right element

Lesson Learned: When users report that clicking isn't working, make the automation script much more aggressive with multiple positions, triple clicks, and immediate testing of each position.
Good Example: ✅ Try multiple relative positions (0.5,0.9), (0.5,0.85), (0.5,0.95), triple click each position, test typing immediately after each click to verify it worked, cover wider area with left/right positions too
Bad Example: ❌ Single click at one position without testing if it actually worked or trying alternative positions

Lesson Learned: The most reliable method for clicking UI elements is template matching using OpenCV. Take a screenshot, compare to saved template image, and click at the exact center of the matched area.
Good Example: ✅ Use cv2.matchTemplate() with a saved input_text_box.png template, check confidence threshold (0.6+), calculate center position from matched location, include fallback to coordinate-based clicking if template not found
Bad Example: ❌ Only relying on coordinate-based clicking without visual verification of what's actually on screen

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ERROR HANDLING ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
Lesson Learned: Always validate string splitting operations before unpacking to avoid "not enough values to unpack" errors. Add debugging output to see what the actual command output looks like.
Good Example: ✅ Check len(parts) >= 2 before unpacking, add print statements to see actual output, use fallback values if parsing fails
Bad Example: ❌ Directly unpacking with x, y = result.split(',') without checking if result actually contains a comma

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ CONFIGURATION MANAGEMENT ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
Lesson Learned: When updating automation timing configurations, update all references including function names, docstrings, print statements, and variable calculations to maintain consistency.
Good Example: ✅ Change function name from wait_13_minutes() to wait_5_minutes(), update docstring, print statements, total_seconds calculation (5 * 60), and all calls to the function
Bad Example: ❌ Only changing the numeric value without updating function names and descriptions, leading to inconsistent code

